<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>五子棋小工具</title>
	<style>
		div {
			font-size: 30px;
		}
		button {
			font-size: 30px;
			width: 150px;
			height: 48px;
		}
		input {
			opacity: 0;
		}
		#log {
		    width: 100%;
		}
	</style>
	<script src="zip/jszip.min.js"></script>
	<script src="script/serviceWorker.js"></script>
</head>
<body>
	<div>
		第一步：下载离线更新包 <a href="https://pan.baidu.com/s/1okeYf_6v6jnrGm3vsKkY-g?pwd=5668" target="_blank">百度网盘</a>
	</div>
	<div>
		第二步：打开zip文件<button id="btn">打开文件</button>
	</div>
	<div id="log"></div>
	<input type="file" id="input"/>
	<script>
		function log(msg) {
			document.getElementById("log").innerText = msg;	
		}
		
		function toURL(zipPath) {
			return new Request(zipPath.slice("updata/".length)).url;
		}
		
		async function getArrBuf(file) {
			return new Promise(function(resolve, reject) {
				let fr = new FileReader();
				fr.onload = function() {
					resolve(fr.result)
				};
				fr.onerror = function() {
					reject(fr.error)
				};
				fr.readAsArrayBuffer(file)
			});
		}
		
		async function deleteCache(cacheKey) {
			return caches.open(cacheKey)
				.then(cache => cache.keys().then(requests => {
					const ps = [];
					requests.map(request => ps.push(cache.delete(request)));
					return Promise.all(ps);
				}))
				.then(() => caches.delete(cacheKey))
		}
		
		function getFilePaths(zip) {
			const paths = [];
			zip.forEach((path, file) => {
				if (!file.dir && path.indexOf("updata/") == 0) paths.push(path)
			})
			return paths;
		}
		
		const btn = document.getElementById("btn");
		const input = document.getElementById("input");
		serviceWorker.registerServiceWorker();
		btn.addEventListener("click", () => input.click());
		input.addEventListener("change", () => {
			if (!('serviceWorker' in navigator)) {
				log("你的浏览器不支持离线缓存");
				return;
			}
			
			const file = input.files[0];
			const zip = new JSZip();
			input.value = "";
			let cacheKey;
			let paths = [];
			let CONTENT_TYPE;

			getArrBuf(file)
			.then(buf => zip.loadAsync(buf, {checkCRC32: true}))
			.then(() => {
			    return new Promise((resolve, reject) => {
			        zip.file("CONTENT_TYPE.json").async("string")
		            .then(str => CONTENT_TYPE = JSON.parse(str))
		            .then(resolve)
		            .catch(reject)
			    })
			})
			.then(() => serviceWorker.postMessage({ cmd: "getCacheKeys"},  3000))
			.then(({currentCacheKey}) => {
				cacheKey = currentCacheKey;
				return currentCacheKey ? deleteCache(currentCacheKey).then(() => currentCacheKey) : Promise.reject("更新缓存失败");
			})
			.then(() => {
			    paths = getFilePaths(zip);
			    return new Promise((resolve, reject) => {
			        async function file2cache() {
			            const path = paths.shift();
			            return zip.file(path).async("blob")
			                .then(b => {
			                    const request = new Request(toURL(path));
			                    const key = path.split(".").pop();
			                    const headers = new Headers();
			                    headers.append("Content-Type", CONTENT_TYPE[key]);
			                    const response = new Response(b,  {
			                        status: 200,
			                        statusText: "OK",
			                        headers
			                    });
			                    log(path);
			                    return caches.open(cacheKey).then(cache => cache.put(request, response.clone()))
			                })
			                .then(() => paths.length == 0 ? resolve() : setTimeout(() => file2cache(), 100) )
			                .catch(reject)
			        }
			        file2cache()
			    })
			})
			.then(() => {log("更新结束");setTimeout(()=>window.top.location.href="./", 5000)})
			.catch(e => log(e.message || "更新失败"))
		})
	</script>
</body>